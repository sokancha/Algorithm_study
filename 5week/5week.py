'''
#실습 2-1
배열이 없을때 ==>
#학생 5명의 시험 점수를 입력받아 합계와 평균을 출력하기
print('학생 그룹 점수의 합계와 평균을 구합니다.')

score1 = int(input('1번 학생의 점수를 입력하세요. :'))
score2 = int(input('2번 학생의 점수를 입력하세요. :'))
score3 = int(input('3번 학생의 점수를 입력하세요. :'))
score4 = int(input('4번 학생의 점수를 입력하세요. :'))
score5 = int(input('5번 학생의 점수를 입력하세요. :'))

total = 0
total += score1
total += score2
total += score3
total += score4
total += score5

print(f'합계는 {total}점입니다.')
print(f'평균은 {total/5}점입니다.')

아래와 같은 요구사항이 있을 때 배열이 없다면
1. 학생 수를 변경하는 경우
2. 특정 학생의 시험 점수를 확인하거나 변경하는 경우
3. 최저점과 최고점을 구하거나 정렬이 필요한 경우

이러한 요구사항을 반영하기 힘들다.
이럴 때는 학생 점수는 하나의 값을 저장하는 변수가 아니라 묶음 단위로 값을 저장하는 배열이라는 자료구조로 다뤄야 한다.

배열에는 객체가 저장되며, 배열에 저장된 객체 하나하나를 원소라 하고, 각 원소는 0,1,2 ... 순으로 인덱스를 부여받는다.

파이썬에서 배열은 리스트와 튜플로 구현할 수 있다.
리스트와 튜플은 데이터 컨테이너라고 한다.
비슷한 기능을 하지만 원소를 변경할 수 있는지 없는지에 따라 차이가 있다.

리스트는 원소를 변경할 수 있는 뮤터블 LIST형 객체이다.
리스트는 연산자 []안에 원소를 쉼표(,)로 구분하여 표기하여 생성할 수 있다.

list01 = [] #[]빈 리스트
list02 = [1,2,3] # [1,2,3]
list03 = ['A', 'B','C'] # ['A', 'B', 'C']

list04 = list() # []빈 리스트
list05 = list('ABC') #['A', 'B', 'C']문자열의 각 문자로부터 원소를 생성
list06 = list([1,2,3]) #[1,2,3] 리스트로부터 원소를 생성
list07 = list([1,2,3]) #[1,2,3] 튜플로부터 원소를 생성
list08 = list({1,2,3}) #[1,2,3] 집합으로부터 원소를 생성

특정 범위의 정수로 구성된 리스트를 만들고자 한다면 range(),list()함수를 조합하여 사용하면 된다.
list09 = list(range(7)) # [0,1,2,3,4,5,6]
list10 = list(range(3,8)) # [3,4,5,6,7]
list11 = list(range(3,13,2)) # [3,5,7,9,11]

리스트의 원소 개수는 리스트를 만들기 전에 반드시 결정해야 한다.
하지만 원솟값을 정하지 않는 리스트는 None을 사용하면 만들 수 있다.
list12 = [None]*5 # [None,None,None,None,None]

튜플은 원소에 순서를 매겨 결합한 것으로 원소를 변경할 수 없는 이뮤터블 자료형이다.
튜플은 원소를 쉼표(,)로 구분하여 나열한 뒤 결합 연산자()로 둘러싸는 방식으로 생성한다.
튜플은 리스트와 다르게 결합 연산자()를 생략할 수 있다.
tuple1 = () # () 빈 튜플
tuple2 = 1, # (1,)
tuple3 = (1,) # (1,)


tuple4 = 1,2,3 #(1,2,3)
tuple5 = 1,2,3, #(1,2,3)
tuple6 = (1,2,3) #(1,2,3)
tuple7 = (1,2,3,) #(1,2,3)
tuple8 = 'A', 'B', 'C', #('A','B','C')

튜플은 원소가 1개인 경우 원소 뒤에 심표를 반드시 입력해줘야한다.
쉼표가 없으면 튜플이 아니라 단순 변수로 여기기 때문이다.
v01 = 1 # 1 튜플이 아닌 하나의 값을 가진 int형 변수
v=2 = (1) # 1 튜플이 아닌 하나의 값을 가진 int형 변수

tuple9 = tuple() #() 빈 튜플
tuple10 = tuple('ABC') # ('A','B','C') 문자열의 각 문자로부터 원소를 생성
tuple11 = tuple([1,2,3]) # (1,2,3)리스트로부터 원소를 생성
tuple12 = tuple([1,2,3)] # (1,2,3)집합으로부터 원소를 생성

리스트와 마찬가지로 특정 범위의 값을 원소로 갖는 튜플은 range()함수가 생성하는 수열(이터러블 객체)을 tuple()함수로 변환하여 만들 수 있다.
tuple13 = tuple(range(7)) #(0,1,2,3,4,5,6)
tuple14 = tuple(range(3,8)) #(3,4,5,6,7)
tuple15 = tuple(range(3,13,2)) # (3,5,7,9,11)

x = [1,2,3]
a,b,c, = x
a,b,c => (1,2,3)


인덱스로 원소레 접근하기

리스트나 튜플의 원소에 접근할 때는 인덱스를 사용한다.

x = [11,22,33,44,55,66,77]
x[2] = 33
x[-3] = 55
x[-4] = 3.14 #리스트 x의 뒤에서 4번째 원소에 새로운 값을 대입
x = [11,22,33,3.14,55,66,77]
x[7] # 존재하지 않는 인덱스이므로 오류를 출력
x[7] = 3.14 #x[7]에는 값을 대입할 수 없으므로 오류를 출력


슬라이스식으로 원소에 접근하기

s[i:j] ... s[i]부터 s[j-1]까지 나열한다.
s[i:j:k] ... s[i]부터 s[j-1]까지 k씩 건너뛰며 나열한다.


s= [11,22,33,44,55,66,77]
s[0:6] # 리스트 s의 0번째 원소부터 5번째 원소까지 출력
[11,22,33,44,55]
s[0:7:2] #리스트s의 0번째 원소부터 6번째 원소 중 2씩 건너뛰며 원소를 출력
[11,33,55,77]
s[-4:-2] #리스트 s의 뒤에서 4번째 원소부터 뒤에서 3번째 원소를 출력
[44,55]
s[3:1] #리스트 s의 j값(1)이 i값(3)보다 작지만 오류가 나지 않음

뮤터블과 이뮤터블의 대입


a,b,c = 1,2,3 #a,b,c에 1,2,3을 각각 대입하여 변숫값을 출력
a => 1
b => 2
c => 3

x = 6
y = 2
x,y = y+2, x+3 # x에(y+2)를 대입하고, y에 (x+3)을 대입
x => 4
y => 9


누적변수 :
'변숫값에 특정값을 더한 결괏값을 다시 대입하여 업데이트한 변수'를 말한다.n+=1에서 n이 바로 누적변수이다. n++역시 n+=1과 같은 표현이다.

뮤터블 자료형 : 리스트,딕셔너리,집합 등이 있으며 값을 변경할 수 있다.
이뮤터블 자료형 : 수, 문자열, 튜플 등이 있으며 값을 변경할 수 없다.

파이썬의 대입 :
- 좌변에 변수 이름이 처음 나온 경우, 그 변수에 맞는 자료형으로 자동 선언해줌.
- 대입식은 값 자체가 아니라 참조하는 객체의 식별 번호를 대입.
- 여러 변수에 여러 값을 한꺼번에 대입할 수 있다.

또한 파이선은 대입 기호= 를 연산식에서 사용하는 +,* 등과 같이 취급하지 않는다. 즉 x+17은 식이지만 x=17은 식이 아니다.

x+17 => 식  => +는 덧셈을 수행하는 연산자이다.
x=17 => 문  => =는 연산자가 아니다.

자료구조의 개념 알아보기
자료구조 : 데이터 단위와 데이터 자체 사이의 물리적 또는 논리적인 관계

리스트와 튜플 1

len()함수로 배열의 원소 수 구하기
x = [15,64,7,3.14,[32,55],'ABC']
len(x) => 6

결과에서 보듯 원소 자체가 리스트(또는 튜플이나 집합 등)인 경우 1개로 계산한다. 즉 , 위의 예에서 [32,55]는 x의 범주에서 볼 때 2개가 아니라 1개이다.

min(),max()함수로 배열의 최솟값과 최댓값 구하기

min(),max()함수의 임수로 리스트나 튜플을 넘겨주면 그 리스트 또는 튜플이 가진 원소 중에서 최솟값 또는 최댓값을 얻을 수 있다.

비교 연산자로 배열의 대소 또는 등가 관계 판단하기
[1,2,3] == [1,2,3]
[1,2,3] < [1,2,4]
[1,2,3,4] <= [1,2,3,4]
[1,2,3] < [1,2,3,5]
[1,2,3] < [1,2,3,5] < [1,2,3,5,6]

파이썬에서는 값을 비교할 때 등가성과 동일성을 사용한다.
등가성 비교는 ==을 동일성 비교는 is를 사용한다.
등가성 비교는 좌변과 우변의 값이 같은지 비교하고, 동일성 비교는 값은 물론 객체의 식별 번호까지 같은지 비교한다.

리스트와 튜플의 공통점과 차이점
공통점 :
1. 이터러블한가?
2. in또는 not in 연산자를 사용할 수 있는가?
3. 덧셈 연산자 + 를 사용할 수 잇는가(연결)?
4. 곱셈 연산자 *를 사용할 수 있는가(반복)?
5. len(), min(),max(), sum(), index(), count()함수를 사용할 수 있는가?
차이점 :
1. 값을 변경할 수 있는가? - 튜플 x
2. 딕셔너리의 key로 사용할 수 있는가? - 리스트 x
3. +=로 연결 대입할 수 있는가? - 튜플 => 내부에서 수행하지 않음.
4. *=로 반복 대입할 수 있는가? - 튜플 => 내부에서 수행하지 않음.
5. 인덱스식을 사용할 수 있는가? - 튜플 => 좌변에 올 수 없음.
6. 슬라이스식을 사용할 수 있는가? - 튜플 => 좌변에 올 수 없음.
7. dell(),append(),clear(),copy(),extend(),insert(),pop(),remove(),reverse()함수를 사용할 수 있는가? - 튜플 x

배열이란 ?
배열 원소의 최댓값 구하기
a의 원소가 3개일때
maximun = a[0]
if a[1] > maximum: maximum = a[1]
if a[2] > maximum: maximum = a[2]

a의 원소가 4개일때
maximum = a[0]
if a[1] > maximum: maximum = a[1]
if a[2] > maximum: maximum = a[2]
if a[3] > maximum: maximum = a[3]

첫 번째 원소(a[0])의 값을 maximum에 대입한다. 그러 다음 if문을 실행하는 과정에서 필요에 따라 maximum을 업데이트한다.
원소 수가 n이면 if문은 n-1번 실행한다.
프롬프트에서 보듯 maximum과 비교하거나 maximum에 대입하는 원소의 인덱스는 1,2,3으로 1씩 증가한다.

def max_of(a) :
    maximum = a[0]
    for i in range(1, len(a)) :
        if a[i] > maximum :
            maximum = a[i]
def_of는 배열 a의 원소중에서 최댓값을 구하는 함수를 정의한 것이다.

#실습 2-2
#시퀀스 원소의 최댓값 출력하기

from typing import Any, Sequence

def max_of(a:Sequence) -> Any :
    """시퀀스형 a원소의 최댓값을 반환 """
    maximum = a[0]
    for i in range(1, len(a)) :
        if a[i] > maximum :
            maximum = a[i]
    return maximum

if __name__ == '__main__' :
    print('배열의 최댓값을 구합니다.')
    num = int(input('원소 수를 입력하세요.')
    x = [None] * num

    for i in range(num)
        x[i] = int(input(f'x[{i}]값을 입력하세요. : '))

    print(f'최댓값은 {max_of(x)}입니다.')


재사용할 수 있는 모듈 작성하기
파이썬에서는 하나의 스크립트 프로그램을 모듈이라고한다.
확장자(.py)를 포함하지 않는 파일의 이름 자체를 모듈 이름으로 사용한다.
실슴 2-2 프로그램의 파일 이름이 max.py이므로 모듈 이름은 max이다.
이 프로그램에서 if문에서는 __name__과 '__main__'이 같은지를 판단한다. 왼쪽 피연산자 __name__은 모듈 이름을 나타내느 변수이고 작성 규칙은 다음과 같다.
- 스크립트 프로그램이 직접 실행될 대 변수 __name__은 '__main__'이다.
- 스크립트 프로그램이 임포트될 때 변수 __name__은 원래의 모듈 이름이다.

모듈 테스트하기
실습 2-2의 모듈 max로 정의된 max_of()함수를 다른 프로그램에서 호출해본다.

#실슴 2-3
#배열 원소의 최댓값을 구해서 출력하기(원솟값을 입력받음)

from max import max_of

print('배열의 최댓값을 구합니다.')
print('주의: "END"를 입력하면 종료한다.')

number = 0
x = []

while True :
    s = input(f'x[{number}]값을 입력하세요.:')
    if s == 'END' :
        break
    x.append(int(s))
    number += 1

print(f'{number}개를 입력했습니다.')
print(f'최댓값은 {max_of(x)}입니다.')

배열의 원솟값을 난수로 결정하기
#실습 2-4
#배열 원소의 최댓값을 구해서 출력하기(원솟값을 난수로 생성)

import random
from max import max_of

print('난수의 최댓값을 구한다.')
num = int(input('난수의 개수를 입력하세요.:')
lo = int(input('난수의 최솟값을 입력하세요.:')
hi = int(input('난수의 최댓값을 입력하세요.:')
x = [None] * num

for i in range(num) :
    x[i] = random.randint(lo,hi)

print(f'{(x)}')
print(f'이 가운데 최댓값은 {max_of(x)}입니다.')
'''



